#!/usr/bin/env python3

import sys
from utils import enum_bits
sys.path.append("../../")
from common import *
from cubecalc import prime_chances, find_line_values
import itertools
import inspect
import pickle
from functools import reduce
from operator import or_
import json

from kms import cubes
from tms import event
from familiars import familiars, red_card_estimate

indent = 0

def p(x):
  global indent
  print("  " * indent + x)

class Block:
  def __init__(self, delim="{}"):
    self.delim = delim

  def __enter__(self):
    global indent
    if self.delim:
      p(self.delim[0])
    indent += 1

  def __exit__(self, exc_type, exc_val, exc_tb):
    global indent
    indent -= 1
    if self.delim:
      p(self.delim[1])

def BlockCol():
  return Block(["{", "};"])

def BlockComma():
  return Block(["{", "},"])

def IndentBlock():
  return Block(None)

# -------------------------------------------------------------------------------------------------
# bake the value ranges into a map of (maxlvl, cube_mask, category_mask, region_mask) -> lines

values = {}

def get_lval(lvals, level, tier, line):
  v = lvals[tier][line]
  if isinstance(v, list):
    try:
      for maxlvl, amt in v:
        if level <= maxlvl:
          return amt
    except:
      print(level, tier, line, v)
      raise
    raise RuntimeError(f"failed to find {Tier(tier).name} {Line(line).name} "+
        f"for level {level}: {v}")
  return v

try:
  with open("gen_find_line_values.py") as f:
    source = f.read()
except:
  source = ""

NonSpecialCategory = [x for x in Category if x not in { LINE_CACHE, NAME, DEFAULT_CUBE }]

# this is a very inefficient way to run the values function for every combination of params and
# generate all the level ranges that have the same values/region/category etc
cursource = inspect.getsource(find_line_values)
if source != cursource:
  source = cursource

  # map params by values returned
  merge = {}
  for cube, category, region in itertools.product(Cube, NonSpecialCategory, Region):
    vals = find_line_values(cube, category, region)
    for level in range(301):
      valsmap = {
        tier: {
          line: get_lval(vals, level, tier, line) for line in vals[tier]
        } for tier in vals
      }
      k = json.dumps(valsmap, sort_keys=True, default=str)
      if k not in merge:
        merge[k] = (valsmap, [])
      merge[k] = (valsmap, merge[k][1] + [(level, cube, category, region)])

  for _, (valsmap, params) in merge.items():
    # group parameters by region
    regions = {}
    for level, cube, category, region in params:
      if region not in regions:
        regions[region] = []
      regions[region] += [(level, cube, category)]

    # generate a map of region_mask -> minlvl, maxlvl, cube_mask, category_mask
    # making sure to merge all overlapping ranges
    region_ranges = {}
    for k, v in regions.items():
      maxlvl = max([level for level, cube, category in v])
      minlvl = min([level for level, cube, category in v])
      cubemask = reduce(or_, [cube for level, cube, category in v])
      categorymask = reduce(or_, [category for level, cube, category in v])

      # see if we can merge with any existing range
      found = False
      for ok, (other_minlvl, other_maxlvl, other_cube, other_category) in region_ranges.items():
        if other_maxlvl == maxlvl and other_minlvl == minlvl:
          found = True
          break

      if found:
        # merge
        del region_ranges[ok]
        region_ranges[ok | k] = (
            minlvl,
            maxlvl,
            other_cube | cubemask,
            other_category | categorymask,
        )
      else:
        # new range
        region_ranges[k] = (minlvl, maxlvl, cube, category)

    # finally generate the values map
    for region, (_, maxlvl, cube, category) in region_ranges.items():
      values[(maxlvl, cube, category, region)] = valsmap

  with open("gen_find_line_values.pickle", "wb") as f:
    pickle.dump(values, f)

  with open("gen_find_line_values.py", "w") as f:
    f.write(source)
else:
  with open("gen_find_line_values.pickle", "rb") as f:
    values = pickle.load(f)

# -------------------------------------------------------------------------------------------------

p(f"/* generated by {sys.argv[0]} - don't edit, edit the script */")
p("#ifndef CUBECALC_GENERATED_H")
p("#define CUBECALC_GENERATED_H")
p("#include \"common.c\"")
p("#include \"utils.c\"")


discl = ""
discl_len = 0
with open("../../../cubechances.txt") as f:
  f.readline()
  f.readline()
  for line in f:
    if line.startswith("="):
      break
    s = line[:-1]
    discl += (f"\"{s}\\n\"")
    discl_len += len(s) + 1

discl_len += 1

p(f"extern char const disclaimer[{discl_len}];")

p(f"void cubecalcGeneratedGlobalInit();")
p(f"void cubecalcGeneratedGlobalFree();")
maps = [ "primeChances", "kms", "tms", "fams", "famsCard" ]

for x in maps:
  p(f"extern Map* {x};");

p(f"extern int const valueGroupsMaxLevel[{len(values)}];")
p(f"extern int const valueGroupsCubeMask[{len(values)}];")
p(f"extern int const valueGroupsCategoryMask[{len(values)}];")
p(f"extern int const valueGroupsRegionMask[{len(values)}];")
p(f"extern Map* valueGroups[{len(values)}];")

def sorted_enum(e):
  return sorted(e, key=lambda z: z.name.lower())

masks_only = [x for x in LineMasks]
masks = masks_only + [x for x in LineVariants]
sorted_line = masks_only + sorted_enum([x for x in Line
                           if x not in {LINE_A, LINE_B, LINE_C, AUTOSTEAL_1, AUTOSTEAL_2}])

lines_count = len(sorted_line)
lines_hi = [(x.name, ((x >> 32) & 0xFFFFFFFF)) for x in Line]
lines_lo = [(x.name, ((x >>  0) & 0xFFFFFFFF)) for x in Line]

categories_combined = [ SECONDARY | FORCE_SHIELD_SOUL_RING ]
CategoryCombined = categories_combined + sorted_enum(NonSpecialCategory)
categories_count = len(NonSpecialCategory) + len(categories_combined)
cubes_count = len([x for x in Cube])
tiers_count = len([x for x in Tier])
regions_count = len([x for x in Region])

p(f"#define ALL_LINES_NUM_MASKS {len(masks_only)}")
p(f"extern int const allLinesHi[{lines_count}];")
p(f"extern int const allLinesLo[{lines_count}];")
p(f"extern char const* const allLineNames[{lines_count}];")

p(f"#define CATEGORY_NUM_COMBINED {len(categories_combined)}")
p(f"extern char const* const categoryNames[{categories_count}];")
p(f"extern int const categoryValues[{categories_count}];")

p(f"extern char const* const cubeNames[{cubes_count}];")
p(f"extern int const cubeValues[{cubes_count}];")

p(f"extern char const* const tierNames[{tiers_count}];")
p(f"extern int const tierValues[{tiers_count}];")

p(f"extern char const* const regionNames[{regions_count}];")
p(f"extern int const regionValues[{regions_count}];")

def enum(e, name=None, sort=True):
  if name is None:
    name = e.__name__
  p(f"enum {name}")
  if sort:
    e = sorted_enum(e)
  with BlockCol():
    for x in e:
      if x.name:
        p(f"{x.name} = 0x{x.value:x},")
  for i, x in enumerate(e):
    if x.name:
      p(f"#define {x.name}_IDX {i}")

for i, x in enumerate(sorted_line):
  p(f"#define {x.name}_IDX {i}")

for x in [Cube, Tier, Region]:
  enum(x)

enum(CategoryCombined, name="Category", sort=False)

# some lines will have half of the bit all zero. to text for them, we replace those hi/lo parts
# with a bit that's not already taken
for name, x in lines_hi:
  s = f"0x{x:x}"
  p(f"#define {name}_HI {s}")

for name, x in lines_lo:
  s = f"0x{x:x}"
  p(f"#define {name}_LO {s}")

for x in masks:
  bits = enum_bits(Line, x, '_HI')
  p(f"#define {x.name}_HI ({bits})")

for x in masks:
  bits = enum_bits(Line, x, '_LO')
  p(f"#define {x.name}_LO ({bits})")

p("#endif")
p("#if defined(CUBECALC_GENERATED_IMPLEMENTATION) && !defined(CUBECALC_GENERATED_UNIT)")
p("#define CUBECALC_GENERATED_UNIT")

for x in maps:
  p(f"Map* {x};");

def arr(x, ctyp, name="buf"):
  p(f"static const BufH({ctyp} const, {name},")
  with IndentBlock():
    for val in x:
      p(f"{val},")
  p(f");")

def arr_flag(x, e, suff="", name="buf"):
  p(f"static const BufH(int const, {name},")
  with IndentBlock():
    for val in x:
      s = enum_bits(e, val, suff) if val else "0"
      p(f"{s},")
  p(f");")


p(f"int const allLinesHi[{lines_count}] = ")
with BlockCol():
  for x in sorted_line:
    p(f"{x.name}_HI,")

p(f"int const allLinesLo[{lines_count}] = ")
with BlockCol():
  for x in sorted_line:
    p(f"{x.name}_LO,")

p(f"char const* const allLineNames[{lines_count}] = ")
with BlockCol():
  for x in sorted_line:
    p(f"\"{x.name.lower().replace('_', ' ')}\",")


p(f"char const* const categoryNames[{categories_count}] = ")
with BlockCol():
  for x in CategoryCombined:
    p(f"\"{category_name(x)}\",")

def simple_enum(e, with_names=True, name=None):
  if not name:
    name = e.__name__
  count = len(e)
  def d(t, x):
    p(f"{t} const {name.lower()}{x}[{count}] = ")
  if with_names:
    d("char const*", "Names")
    with BlockCol():
      for x in e:
        p(f"\"{x.name.lower()}\",")
  d("int", "Values")
  with BlockCol():
    for x in e:
      p(f"{x.value},")

for x in [Cube, Tier, Region]:
  simple_enum(sorted_enum(x), name=x.__name__)

simple_enum(CategoryCombined, with_names=False, name="Category")

init_funcs = []

def init_func(x):
  global init_funcs
  p(f"static void {x}()")
  init_funcs.append(x)

def container(t, d):
  p("static Container container =")
  with BlockCol():
    p(f".type = CONTAINER_{t.upper()},")
  p(f"container.data = {d};")

init_func("primeChancesInit")
with Block():
  p("primeChances = MapInit();")
  for cube, data in prime_chances.items():
    with Block():
      if isinstance(data, dict):
        p("Map* cube = MapInit();")
        for tier, x in data.items():
          with Block():
            arr(x, "float")
            p(f"MapSet(cube, {Tier(tier).name}, (void*)buf.data);")
        container("map", "cube")
      else:
        arr(data, "float")
        container("buf", "(void*)buf.data")
      p(f"MapSet(primeChances, {Cube(cube).name}, (void*)&container);")


def lines_map(name, x):
  p(f"{name} = MapInit();")
  for cube_mask, categories in x.items():
    with Block():
      p(f"Map* categories = MapInit();")
      for category_mask, tiers in categories.items():
        with Block():
          p(f"Map* tiers = MapInit();")
          for tier, linedata in tiers.items():
            with Block():
              lines = [x[0] for x in linedata]
              arr_flag(lines, Line, "_HI", name="lineHi")
              arr_flag(lines, Line, "_LO", name="lineLo")
              arr([x[1] for x in linedata], "float", name="onein")
              # tcc can't figure out that these arrays are compile time const
              p("static const LineData linedata = ")
              with BlockCol():
                p(".onein = onein.data,")
                p(".lineHi = lineHi.data,")
                p(".lineLo = lineLo.data,")
              p(f"MapSet(tiers, {Tier(tier).name}, (void*)&linedata);")
          p(f"MapSet(categories, {enum_bits(Category, category_mask)}, tiers);")
      p(f"MapSet({name}, {enum_bits(Cube, cube_mask)}, categories);")


init_func("dataInit")
with Block():
  lines_map("kms", cubes)
  lines_map("tms", event)
  lines_map("fams", familiars)
  lines_map("famsCard", red_card_estimate)

p(f"void cubecalcGeneratedGlobalFree()")
with Block():
  for x in maps:
    p(f"{x}Free();");
  p(f"valueGroupsFree();");

p(f"int const valueGroupsMaxLevel[{len(values)}] = ")
with BlockCol():
  for k, v in values.items():
    level, cube, category, region = k
    p(f"{level},")

p(f"int const valueGroupsCubeMask[{len(values)}] = ")
with BlockCol():
  for k, v in values.items():
    level, cube, category, region = k
    p(f"{enum_bits(Cube, cube)},")

p(f"int const valueGroupsCategoryMask[{len(values)}] = ")
with BlockCol():
  for k, v in values.items():
    level, cube, category, region = k
    p(f"{enum_bits(Category, category)},")

p(f"int const valueGroupsRegionMask[{len(values)}] = ")
with BlockCol():
  for k, v in values.items():
    level, cube, category, region = k
    p(f"{enum_bits(Region, region)},")

p(f"Map* valueGroups[{len(values)}];")

init_func("valuesInit")
with Block():
  for i, (k, v) in enumerate(values.items()):
    level, cube, category, region = k
    for tier, values in v.items():
      lines_hi = []
      lines_lo = []
      for line, value in values.items():
        line_hi = " | ".join([f"{x.name}_HI" for x in Line if line & x])
        if not line_hi:
          line_hi = 0
        line_lo = " | ".join([f"{x.name}_LO" for x in Line if line & x])
        if not line_lo:
          line_lo = 0
        lines_hi.append(line_hi)
        lines_lo.append(line_lo)
      with Block():
        p(f"static const int linesHi[{len(values)}] = ")
        with BlockCol():
          for x in lines_hi:
            p(f"{x},")
        p(f"static const int linesLo[{len(values)}] = ")
        with BlockCol():
          for x in lines_lo:
            p(f"{x},")
        p(f"static const int vals[{len(values)}] = ")
        with BlockCol():
          for k, v in values.items():
            p(f"{v},")
        p(f"valueGroupsSet({i}, {tier}, {len(values)}, linesHi, linesLo, vals);")


p(f"void cubecalcGeneratedGlobalInit()")
with Block():
  [p(f"{x}();") for x in init_funcs]


p(f"char const disclaimer[{discl_len}] = ")
p(discl)
p(";")

p("#endif")
